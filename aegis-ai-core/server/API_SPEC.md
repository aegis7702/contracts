# Aegis PoC API Spec (v0.1)

Base URL (local):
- `http://127.0.0.1:8000`

All endpoints are JSON over HTTP.

## Common Types

### `AuditResult`

```json
{
  "label": "SAFE",
  "confidence": 0.82,
  "name": "Precheck@0x...",
  "summary": "1 line summary",
  "description": "2-3 lines\\nuse \\n for line breaks\\n...",
  "reasons": ["reason 1", "reason 2"],
  "matched_patterns": ["optional", "strings"]
}
```

Notes:
- `label` is always `"SAFE"` or `"UNSAFE"`.
- `reasonsText` fields are produced by the backend by joining `reasons[]` with `\\n` (not generated by the LLM).

## Endpoints

### `GET /v1/health`

Response:

```json
{ "ok": true }
```

### `POST /v1/chat`

Minimal LLM wrapper endpoint.

Request:

```json
{
  "text": "Write a one-line summary of EIP-7702.",
  "system": "optional system prompt",
  "model": "optional model override",
  "maxTokens": 200,
  "temperature": 0.2
}
```

Response:

```json
{ "text": "..." }
```

### `POST /v1/tx/precheck`

Precheck API called by a 7702 wallet before broadcasting a transaction.

Request:

```json
{
  "chainId": 31337,
  "from": "0xYourWallet",
  "to": "0xYourWallet",
  "value": "0",
  "data": "0x...",
  "txType": 4,
  "authorizationList": []
}
```

Response:

```json
{
  "chainId": 31337,
  "allow": true,
  "audit": { "label": "SAFE", "confidence": 0.7, "name": "...", "summary": "...", "description": "...", "reasons": ["..."], "matched_patterns": [] },
  "reasonsText": "reason1\\nreason2",
  "walletCurrentImpl": "0xImpl",
  "walletCurrentImplRecord": {
    "implAddress": "0xImpl",
    "verdict": 1,
    "name": "...",
    "summary": "...",
    "description": "...",
    "reasons": "...",
    "updatedAt": 1730000000,
    "codehash": "0x..."
  }
}
```

### `POST /v1/impl/scan`

Analyze an implementation address using `eth_getCode` (runtime bytecode) and write the result on-chain via
`ImplSafetyRegistry.setRecordCurrent(...)`.

Request:

```json
{
  "chainId": 31337,
  "implAddress": "0xImpl"
}
```

Response:

```json
{
  "chainId": 31337,
  "implAddress": "0xImpl",
  "audit": { "label": "UNSAFE", "confidence": 0.9, "name": "...", "summary": "...", "description": "...", "reasons": ["..."], "matched_patterns": [] },
  "reasonsText": "reason1\\nreason2",
  "registryTxHash": "0x..."
}
```

### `POST /v1/impl/audit-apply`

Audit an impl during initial registration or a swap.

- `mode=init`: audit the new impl and, if allowed, return a wallet self-call tx template for `aegis_init(...)`
- `mode=swap`: always record the standalone new-impl audit, and additionally record a separate "swap compatibility"
  audit on-chain.
  - In swap mode, up to **two on-chain writes** can happen: (newImpl standalone) + (swap compatibility).

Request:

```json
{
  "chainId": 31337,
  "wallet": "0xYourWallet",
  "newImplAddress": "0xNewImpl",
  "mode": "swap"
}
```

Response:

```json
{
  "chainId": 31337,
  "wallet": "0xYourWallet",
  "mode": "swap",
  "currentImpl": "0xCurrentImpl",
  "newImpl": "0xNewImpl",
  "newImplAudit": { "label": "SAFE", "confidence": 0.8, "name": "...", "summary": "...", "description": "...", "reasons": ["..."], "matched_patterns": [] },
  "newImplReasonsText": "reason1\\nreason2",
  "newImplRegistryTxHash": "0x...",
  "swapAudit": { "label": "SAFE", "confidence": 0.7, "name": "...", "summary": "...", "description": "...", "reasons": ["..."], "matched_patterns": [] },
  "swapReasonsText": "reason1\\nreason2",
  "swapRegistryTxHash": "0x...",
  "allow": true,
  "txTemplate": { "to": "0xYourWallet", "data": "0x...", "value": "0x0" }
}
```

Notes:
- The backend does not hold the wallet private key, so the client must send the actual
  `aegis_init/aegis_setImplementation` transaction using `txTemplate`.

### `POST /v1/wallet/watch`

Register a wallet for worker-based post-audit monitoring.

Notes:
- The worker writes a TxNote on-chain for every new transaction from watched wallets.
- Worker freeze policy:
  - The worker decides whether to freeze based only on the **LLM postaudit label**.
  - The postaudit prompt is designed to force label="SAFE" when `receipt.status == 0x0` (revert/failure),
    so in normal operation a reverted tx should not trigger a freeze. (TxNote is still written.)

Request:

```json
{
  "chainId": 31337,
  "wallet": "0xYourWallet"
}
```

Response:

```json
{
  "wallet": "0xYourWallet",
  "startBlock": 123456,
  "addedAt": "2026-02-07T00:00:00+00:00"
}
```

### `GET /v1/wallet/watch?chainId=...`

Response:

```json
{
  "chainId": 31337,
  "items": [
    { "wallet": "0x...", "startBlock": 123, "addedAt": "..." }
  ]
}
```

### `DELETE /v1/wallet/watch?chainId=...&wallet=...`

Response:

```json
{ "removed": true }
```

### `GET /v1/wallet/{wallet}/tx/{txHash}?chainId=...`

Fetch the on-chain TxNote.

Response:

```json
{
  "wallet": "0xYourWallet",
  "txHash": "0x...",
  "note": {
    "name": "...",
    "summary": "...",
    "description": "...",
    "reasons": "reason1\\nreason2",
    "updated_at": 1730000000
  }
}
```
